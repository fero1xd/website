---
title: "Why I Started Using Effect.ts"
description: "An honest look at Effect.ts, what it is, what problem it actually solves, and whether it's worth the learning curve."
date: "2026-02-09"
tags: ["typescript", "effect"]
published: true
---

For the longest time, I dismissed [Effect.ts](https://effect.website). "Oh great, another batteries-included framework that I don't need." I'd seen enough of those come and go, and my codebase was working fine with plain TypeScript. Why would I add another abstraction layer on top of everything?

Then I actually tried it.

It didn't click immediately because these things never do, but the more I used it, the more things started making sense. Little by little, patterns emerged and error handling became predictable. Async code became manageable, and somewhere along the way I realized I wasn't fighting my own code anymore.

What really sold me was spending a day reading through the documentation. Honestly, the docs are excellent because they're well-structured, full of examples, and they actually explain *why* things work the way they do instead of just showing you how. That's rare.

So if you've heard about Effect and wondered what the hype is about, or if you're tired of chasing down silent failures in your async code, this post is for you. We'll look at the core problem Effect solves, how it actually works in practice, and whether it's worth adding to your stack. I'll also share the downsides because there are some, and I want you to be able to make an informed decision.

## The Real Problem Effect Solves

Here's what nobody tells you about professional TypeScript code: you have no idea what can go wrong just by looking at a function signature.

```typescript
async function getUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}
```

This looks clean, right? But what happens when the network is down? What about when the server returns a 404, or the JSON is malformed, or the server just times out and leaves you hanging?

TypeScript just tells you this returns `Promise<User>`, which is honestly a lie. This function can explode in a dozen different ways, and the type system is pretending everything is fine. This is the fundamental problem, and it's not really TypeScript's fault because JavaScript was never designed with error tracking in mind.

## Enter the Effect Type

Effect's core innovation is deceptively simple. Instead of `Promise<User>`, you get a type signature that looks like this:

```typescript
Effect<User, NetworkError | ParseError, never>
```

It has three type parameters that tell you exactly what's going on. The first one is what you get when things work, the second is what errors can happen, and the third is what services or dependencies your code needs to run.

That's it. That's really the whole idea. Errors become part of the type signature.

Now when you look at a function, you actually know what can go wrong:

```typescript
const getUser = (id: string): Effect.Effect<User, NetworkError | NotFoundError> =>
  Effect.tryPromise({
    try: () => fetch(`/api/users/${id}`).then(r => r.json()),
    catch: (e) => new NetworkError({ cause: e })
  });
```

The compiler won't let you ignore these errors because you have to handle them somewhere before your code will compile. No more silent failures, and no more wondering if something can throw.

## Writing Effect Code

The syntax takes some getting used to because Effect uses generators to make async code look synchronous:

```typescript
import { Effect } from "effect";

const program = Effect.gen(function* () {
  const user = yield* getUser("123");
  const posts = yield* getUserPosts(user.id);
  
  return { user, posts };
});
```

Each `yield*` works like an `await`, but with full error tracking. If `getUser` can fail with a `NetworkError`, the compiler knows about it. If `getUserPosts` can fail with a `DatabaseError`, that gets tracked too. The final `program` type includes all possible errors from everything you called.

You literally can't forget to handle something because the types won't let you compile until you do.

## Composition Is Where It Clicks

This is where Effect really started making sense to me. Once you have these typed effects, you can compose them in ways that would be painful to write by hand.

If you need to add retries, Effect has a `Schedule` module that handles exponential backoff, jitter, and retry limits all for you:

```typescript
import { Effect, Schedule } from "effect";

const resilientGetUser = getUser("123").pipe(
  Effect.retry(Schedule.exponential("100 millis").pipe(
    Schedule.compose(Schedule.recurs(3))
  ))
);
```

If you need a timeout, you can just chain it on:

```typescript
const withTimeout = getUser("123").pipe(
  Effect.timeout("5 seconds")
);
```

And if you need a fallback value when things fail:

```typescript
const withFallback = getUser("123").pipe(
  Effect.catchAll(() => Effect.succeed(defaultUser))
);
```

All of these compose cleanly, and the types update automatically as you chain things together. When you catch all errors, the error type becomes `never`. Add a retry and the error type stays the same. You build small pieces that snap together without any surprises.

## What Else Can Effect Do

Once you're comfortable with the basics, there's a lot more to explore because Effect isn't just about error handling. It's actually a complete toolkit for building robust applications.

Dependency injection is built right into the type system. Remember that third type parameter I mentioned earlier? It tracks what services your code needs, and you can define interfaces, swap implementations for testing, and the compiler ensures you've provided everything before the code runs. There are no runtime surprises.

Effect Platform gives you cross-runtime support for HTTP clients, file systems, and more. You can write your code once and run it on Node, Bun, Deno, or in the browser because the platform layer abstracts away all the differences.

Structured concurrency means you get proper fiber management, parallel execution, and resource cleanup that actually works. No more dangling promises or forgotten cleanup handlers.

The ecosystem keeps growing with things like Schema for validation and RPC for type-safe APIs. You don't need all of it, but it's nice knowing it's there when you do.

## The Honest Downsides

I'd be doing you a disservice if I didn't mention the problems because there are definitely some.

The biggest issue right now is bundle size. Effect is not a small library, and if you're building something where every kilobyte matters like a lightweight frontend widget, the overhead might not be worth it. For backend services or larger applications it's usually fine, but it's something to think about.

The good news is that Effect v4 is specifically addressing this. The team is working on making the library more tree-shakeable and reducing the baseline footprint, so if bundle size is your main concern it might be worth waiting for v4 or at least keeping an eye on it.

The learning curve is also real. The syntax is different, the mental model takes time to internalize, and your team needs to be on board with it. But once it clicks, and it does click, you won't want to go back.

## Getting Started

```bash
npm install effect
```

Start small. Pick one function that does something error-prone like a network call or file operation and rewrite it with Effect. See how it feels.

```typescript
import { Effect, Console } from "effect";

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.fail(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b);

const program = Effect.gen(function* () {
  const result = yield* divide(10, 2);
  yield* Console.log(`Result: ${result}`);
});

Effect.runPromise(program);
```

The [documentation](https://effect.website/docs/introduction) is genuinely worth reading because I spent a full day going through it and came out the other side actually understanding the library. The Discord community is helpful too if you get stuck on something.

Give it a try. The initial friction is real, but so is the payoff.
